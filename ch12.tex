%!TEX root = da-dev.tex

We have reached the end of this book. In this chapter we will review what we have learned and have a brief look at what else is there in the field of distributed algorithms. The exercise form a small project in which we will analyse one graph problem\mydash edge dominating sets\mydash from the perspective of distributed algorithms.


\section{What Have We Learned?}

\paragraph{High-Level Skills.}

By now, you have learned a new mindset\mydash an entirely new way to think about computation. You can reason about distributed systems, which has many challenges that we do not usually encounter in basic courses on algorithms:
\begin{itemize}
    \item You can deal with \emph{unknown systems}: you can design algorithms that work correctly in any computer network, no matter how the computers are connected together, no matter how we choose the port numbers, and no matter how we choose the unique identifiers.
    \item You can deal with \emph{partial information}: you can solve many problems in sublinear time, so that each node only sees a small part of the network, and nevertheless the nodes produce outputs that are globally consistent.
    \item You can deal with \emph{parallelism}: fast distributed algorithms are also necessarily highly parallel algorithms, in which a large number of nodes operate simultaneously.
\end{itemize}
These skills are in no way specific to distributed algorithms\mydash they play a key role also in many other areas of modern computer science. For example, dealing with unknown systems is necessary if we want to design \emph{fault-tolerant} algorithms, dealing with partial information is the key element in e.g.\ \emph{online algorithms} and \emph{streaming algorithms}, and parallelism is of course the cornerstone of any algorithm that makes the most out of modern \emph{multicore CPUs}, \emph{GPUs}, and \emph{computing clusters}.


\paragraph{Learning Objectives.}

Let us now have a more detailed look of the detailed learning objectives. The following is based on the scope of the lecture course \emph{Distributed Algorithms} that I lecture at Aalto University. This is a 12-week course, with one 2-hour lecture and one 2-hour exercise session per week, worth 5 ECTS credits, which roughly translates to 133 hours of work in total. Roughly speaking, normal exercises are something that the students should be able to solve, while the exercises marked with a star are material that goes beyond the learning objectives.


\paragraph{Objective 1: Models.}

As the title of this book suggests, by now you should know precisely what is a \emph{distributed algorithm}. You can now define in a formally precise manner what is a distributed algorithm in each of the following models:
\begin{itemize}[noitemsep]
    \item deterministic $\PN$-algorithms (Chapter~\ref{ch:pn}),
    \item deterministic $\LOCAL$-algorithms (Chapter~\ref{ch:local}),
    \item deterministic $\CONGEST$-algorithms (Chapter~\ref{ch:congest}),
    \item randomised $\PN$-algorithms (Chapter~\ref{ch:rand}),
    \item randomised $\LOCAL$-algorithms (Chapter~\ref{ch:rand}),
    \item randomised $\CONGEST$-algorithms (Chapter~\ref{ch:rand}).
\end{itemize}


\paragraph{Objective 2: Algorithms.}

You have now learned how to \emph{design} a distributed algorithm in each of these models, how to \emph{prove} that the algorithm is correct, and how to \emph{analyse} the running time of the algorithm.

We have seen many concrete examples of distributed algorithms, and in the exercises you have designed many more. At least, you should be familiar with the following algorithms that serve as building blocks:
\begin{itemize}
    \item Colouring paths in $O(\log^* n)$ rounds with deterministic algorithms in the $\LOCAL$ model (Section~\ref{sec:algo-p3cbit}).
    \item Colouring graphs in $O(\log n)$ rounds w.h.p.\ with randomised algorithms in the $\LOCAL$ model (Section~\ref{sec:bdrand}).
    \item Gathering everything in $O(\diam(G))$ rounds in the $\LOCAL$ model (Section~\ref{sec:gather}).
    \item Maximal matching in bipartite graphs in $O(\Delta)$ rounds in the $\PN$ model (Section~\ref{sec:bmm}).
    \item All-pairs shortest paths in $O(n)$ rounds in the $\CONGEST$ model (Section~\ref{sec:apsp}).
\end{itemize}
These algorithm highlight the key aspect of the models of computing, they illustrate important techniques for algorithm design and analysis, and they also serve as key building blocks that can be used as subroutines in many other algorithms.

Indeed, by far the most important algorithm design technique is \emph{reductions}. To solve a problem $X$, you first show that given a solution to another problem $Y$, you can easily solve problem $X$, too. Then it is sufficient to find an algorithm for solving problem $Y$; in many cases, you can simply reuse an existing algorithm.

\emph{Graph colouring} is a prime example of the power of reductions: given an efficient distributed algorithm for graph colouring, we can also solve many other problems efficiently. In algorithm design, graph colouring helps with \emph{symmetry breaking} and a graph colouring makes it easier to \emph{coordinate} or \emph{schedule} the activities of the nodes in a conflict-free manner\mydash for example, we can proceed by colour classes, so that in step $i$ nodes of colour $i$ are active.

In the $\PN$ model, it is impossible to break symmetry with deterministic algorithms. Nevertheless, we can still use graph colourings in algorithm design: recall the vertex cover algorithm from Section~\ref{sec:vc3}, in which we were able to produce a $2$-colouring out of thin air, and exploit it in algorithm design.


\paragraph{Objective 3: Lower Bounds.}

You can now also prove what \emph{cannot be computed} with distributed algorithms, and \emph{what cannot be computed} efficiently. There are two main arguments that we use:
\begin{itemize}
    \item Covering maps can be used to show that many problems cannot be solved \emph{at all} in the $\PN$ model (Chapter~\ref{ch:covering-map}).
    \item Local neighbourhoods can be used to show that many problems cannot be solved \emph{efficiently} in any of the models (Chapters \ref{ch:intro-neg} and~\ref{ch:local-neighbourhoods}).
\end{itemize}
For many problems these two basic tools\mydash together with a bit of creativity in how to apply them\mydash are all that is needed. However, there are some problems that need a bit more heavyweight machinery. The key example is, again, graph colouring.

While it is possible to, e.g., find a $3$-colouring of a path in $O(\log^* n)$ rounds with deterministic $\LOCAL$-algorithms, this is not possible in $O(1)$ rounds. We have now seen \emph{two} different ways to prove this result; hopefully you are comfortable with at least one of the proofs:
\begin{enumerate}
    \item The fairly elementary but a bit technical proof that we presented in Section~\ref{sec:intro-neg-logstar}. This argument actually gives a tight result, showing that the problem cannot be solved in $o(\log^* n)$ rounds.
    \item The proof that uses Ramsey's theorem from Chapter~\ref{ch:ramsey-app}. Here the proof itself is fairly easy, and it can be easily generalised to many other results. Unfortunately, it relies on Ramsey's theorem, which is again a bit tedious to prove. Moreover, our proof is a bit sloppy; we only showed that $O(1)$ rounds is not sufficient. To prove the stronger claim that $o(\log^* n)$ rounds is not sufficient requires more work.
\end{enumerate}


\paragraph{Objective 4: Graph Theory.}

The theory of distributed algorithms often relies heavily on graph theory. We use graph theory to define the problems that we want to solve, we use graph theory to define the model of computing that we use, and we also use graph theory in algorithm design and analysis, as well as in lower bound proofs.

By now you should be familiar with the standard graph-theoretic terms that we introduced in Chapter~\ref{ch:graphs}, and you should be able to prove simple graph-theoretic results that e.g.\ show connections between different graph problems. This is after all what we will often need in reductions if we want to apply existing distributed algorithms in order to solve new problems.

A typical example of a graph-theoretic statement that you should be able to easily prove is the connection between maximal matchings and approximate vertex covers (Exercise~\ref{ex:mmvc}). This immediately gives you a distributed algorithm that finds a \Apx{2} of a minimum vertex cover, provided that you have a distributed algorithm that finds a maximal matching\mydash and to find maximal matchings, you can once again resort to graph colourings. This kind of results can be of course used directly also outside the area of distributed algorithms.

We have also encountered two concepts that go beyond elementary graph theory. The first one is the concept of covering maps (Chapter~\ref{ch:covering-map}); while we studied covering maps in the context of port-numbered networks, an analogous concept with similar properties can be defined for e.g.\ undirected or directed graphs. The second one is Ramsey's theorem; we presented Ramsey's theorem in a very general form, but the special case of $k = 2$ has many direct graph-theoretic applications. While the proof of Ramsey's theorem is a bit tedious in the general case, you should be able to prove it without much difficulty e.g.\ for the special case of $c = 2$ and $k = 2$.


\section{What Else Exists?}

FIXME


\section{Exercises}

In the following exercises, we will study distributed approximation algorithms for the edge dominating set problem. We will first show that the problem is easy to approximate within factor $4$ in general graphs. Then we will have a look at some special cases, and derive tight upper and lower bounds for the approximation ratio. We use the abbreviation \emph{MEDS} for a minimum edge dominating set.

\begin{ex}[general case]\label{ex:edsfirst}
    Design a $\PN$-algorithm that finds a \Apx{4} of MEDS.
    
    \hint{Use the idea of Section~\ref{sec:vc3}. Show that the edge set $M \subseteq E$ defined in \eqref{eq:vc3-M} is a $4$-approximation of MEDS. To this end, consider an optimal solution $D^*$ and show that each edge of $D^*$ is adjacent to at most $4$ edges of~$M$.}
\end{ex}

\begin{ex}[\Reg{2}, upper bounds]
    Show that the following is possible in \Reg{2} graphs:
    \begin{subex}
        \item finding a \Apx{3} of MEDS in $O(1)$ time in the $\PN$ model
        \item finding a \Apx{2} of MEDS in $O(\log^* n)$ time in the $\LOCAL$ model
        \item finding a \Apx{2} of MEDS with a randomised algorithm in the $\PN$ model
    \end{subex}
\end{ex}

\begin{exs}[\Reg{2}, lower bounds]
    Show that the following is not possible in \Reg{2} graphs:
    \begin{subex}
        \item finding a \Apx{2.999} of MEDS in the $\PN$ model
        \item finding a \Apx{2.999} of MEDS in $O(1)$ time in the $\LOCAL$ model
    \end{subex}
\end{exs}

\begin{ex}[\Reg{4}, upper bound]
    Show that it is possible to find a \Apx{3.5} of MEDS in \Reg{4} graphs in constant time in the $\PN$ model.
    
    \hint{Consider an algorithm that selects all edges that have port number $1$ in at least one end. Derive an upper bound on the size of the solution and a lower bound on the size of an optimal solution, as a function of $|V|$.}
\end{ex}

\begin{ex}[\Reg{4}, lower bound]
    Show that it is not possible to find a \Apx{3.499} of MEDS in \Reg{4} graphs in the $\PN$ model.
    
    \hint{Use the construction of Exercise~\ref{ex:cover-reg}a.}
\end{ex}

\begin{ex}[\Reg{3}, lower bound]
    Show that it is not possible to find a \Apx{2.499} of MEDS in \Reg{3} graphs in the $\PN$ model.
    
    \hint{Use the construction of Exercise~\ref{ex:cover-three-reg1}.}
\end{ex}

\begin{exs}[\Reg{3}, upper bound]\label{ex:edslast}
    Show that it is possible to find a \Apx{2.5} of MEDS in \Reg{3} graphs in constant time in the $\PN$ model.
    
    \hint{Let $G = (V,E)$ be a $3$-regular graph. We say that a set $D \subseteq E$ is \emph{good} if it satisfies the following properties:
    \begin{enumerate}
        \item $D$ is an edge cover for $G$,
        \item the subgraph induced by $D$ does not contain a path of length $3$.
    \end{enumerate}
    Put otherwise, $D$ induces a spanning subgraph that consists of node-disjoint stars. Prove that
    \begin{enumerate}
        \item any good set $D$ is a \Apx{2.5} of MEDS,
        \item there is a distributed algorithm that finds a good set $D$.
    \end{enumerate}
    The distributed algorithm has to exploit the port numbers of the edges. One possible approach is this: First, use the port numbers to find nine matchings, $M_1, M_2, \dotsc, M_9$, such that each node is incident to an edge in at least one of the sets $M_i$; do not worry if some edges are present in more than one matching. Then construct an edge cover $D$ by greedily adding edges from the sets $M_i$; in step $i = 1, 2, \dotsc, 9$ you can consider all edges of $M_i$ in parallel. Finally, eliminate paths of length three by removing redundant edges in order to make $D$ a good set; again, in step $i = 1, 2, \dotsc, 9$ you can consider all edges of $M_i$ in parallel.}
\end{exs}


\section{Bibliographic Notes}

Exercises \ref{ex:edsfirst}--\ref{ex:edslast} are inspired by our work \cite{suomela10eds,astrand10weakly-coloured}.
